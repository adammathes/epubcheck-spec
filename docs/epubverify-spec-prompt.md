# Project: epubverify-spec — Language-Independent EPUB Validation Test Suite

## Goal

Build a comprehensive, machine-readable test suite for EPUB validation that any implementation (Go, Rust, Zig, C, whatever) can test against. The test suite is validated against the reference Java epubcheck to ensure correctness. This repo is the source of truth — implementations consume it, they don't define it.

## Why This Exists Separately

We want to build a native EPUB validator to replace the Java-only w3c/epubcheck. But before writing any validation code, we need a rock-solid test suite that:
1. Defines exactly what "correct" validation means
2. Is validated against the reference Java implementation
3. Can be consumed by any language's test harness
4. Tracks which spec requirements are covered
5. Knows what checks matter most via real-world frequency analysis

The test suite is the hard part. The implementation is just making tests pass.

## Scope & Maturity Levels

The reference epubcheck has ~200+ distinct checks across 10 categories (PKG, RSC, OPF, HTM, NAV, NCX, CSS, MED, ACC, CHK). We don't need all of them on day one. Every check in our registry gets a maturity level:

**Level 1 — "Catches pandoc problems" (~30 checks)**
Container structure, basic OPF, manifest/spine cross-refs, required metadata. The minimum viable validator.

**Level 2 — "Daily driver" (~80 checks)**  
Full resource reference validation, fallback chains, content well-formedness, fragment identifiers, URL validation, media type verification, basic EPUB 2.

**Level 3 — "Production validator" (~140 checks)**
CSS validation, navigation edge cases, fixed-layout, full EPUB 2, encoding checks, image validation.

**Level 4 — "Full conformance" (~200+ checks)**
Accessibility, encryption, media overlays, dictionaries, collections, deep HTML5 validation.

We build Level 1 first, then use frequency analysis to prioritize what comes next.

## Environment Setup

Run `./bootstrap.sh` first — it installs Java, reference epubcheck, test data, and tools. See the separate bootstrap.sh file.

## Architecture

```
epubverify-spec/
├── bootstrap.sh
├── checks.json                     # Machine-readable registry of ALL checks
├── fixtures/
│   ├── src/                        # Human-readable source for each test epub
│   │   ├── valid/
│   │   │   ├── minimal-epub3/
│   │   │   │   ├── mimetype
│   │   │   │   ├── META-INF/
│   │   │   │   │   └── container.xml
│   │   │   │   └── OEBPS/
│   │   │   │       ├── content.opf
│   │   │   │       ├── nav.xhtml
│   │   │   │       └── chapter1.xhtml
│   │   │   └── minimal-epub2/
│   │   └── invalid/
│   │       ├── ocf-mimetype-missing/
│   │       ├── ocf-mimetype-compressed/
│   │       └── ... (many more, organized by check)
│   ├── epub/                       # Built epub zips (generated by build script)
│   │   ├── valid/
│   │   └── invalid/
│   └── external/                   # Real-world test epubs (downloaded)
│       ├── epub3-samples/
│       ├── gutenberg/              # Sample from Project Gutenberg
│       └── standard-ebooks/        # Sample from Standard Ebooks
├── expected/                       # Our curated expected results
│   ├── valid/
│   └── invalid/
├── reference/                      # Raw reference epubcheck output (generated)
│   ├── valid/
│   └── invalid/
├── analysis/                       # Frequency & coverage analysis output
│   ├── check-frequency.txt         # How often each check fires on real epubs
│   ├── known-message-ids.txt       # All message IDs seen in the wild
│   └── coverage-report.md          # Current coverage vs full epubcheck
├── scripts/
│   ├── build-fixtures.sh
│   ├── build-special-fixtures.py   # Fixtures needing non-standard zip manipulation
│   ├── generate-reference.sh
│   ├── verify-expected.sh
│   ├── compare-implementation.sh
│   ├── parity-report.sh
│   ├── discover-checks.sh         # Find all checks via corpus analysis
│   ├── frequency-analysis.sh      # Rank checks by real-world frequency
│   └── fetch-corpus.sh            # Download real-world epub corpus
├── Makefile
└── README.md
```

## Implementation Plan

### Phase 1: Scaffold + Minimal Valid EPUBs

Start here. Build the foundation before anything else.

1. Create directory structure.

2. Create `fixtures/src/valid/minimal-epub3/` — the smallest valid EPUB 3. This is just 5 files:

**mimetype** (must be exact, no trailing newline):
```
application/epub+zip
```

**META-INF/container.xml**:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">
  <rootfiles>
    <rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/>
  </rootfiles>
</container>
```

**OEBPS/content.opf** (minimal valid package document):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<package xmlns="http://www.idpf.org/2007/opf" version="3.0" unique-identifier="uid">
  <metadata xmlns:dc="http://purl.org/dc/elements/1.1/">
    <dc:identifier id="uid">urn:uuid:12345678-1234-1234-1234-123456789012</dc:identifier>
    <dc:title>Test Book</dc:title>
    <dc:language>en</dc:language>
    <meta property="dcterms:modified">2025-01-01T00:00:00Z</meta>
  </metadata>
  <manifest>
    <item id="nav" href="nav.xhtml" media-type="application/xhtml+xml" properties="nav"/>
    <item id="chapter1" href="chapter1.xhtml" media-type="application/xhtml+xml"/>
  </manifest>
  <spine>
    <itemref idref="chapter1"/>
  </spine>
</package>
```

**OEBPS/nav.xhtml**:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head><title>Navigation</title></head>
<body>
  <nav epub:type="toc">
    <h1>Table of Contents</h1>
    <ol>
      <li><a href="chapter1.xhtml">Chapter 1</a></li>
    </ol>
  </nav>
</body>
</html>
```

**OEBPS/chapter1.xhtml**:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head><title>Chapter 1</title></head>
<body>
  <h1>Chapter 1</h1>
  <p>Hello, world.</p>
</body>
</html>
```

3. Write `scripts/build-fixtures.sh`:

```bash
#!/bin/bash
set -euo pipefail

FIXTURES_SRC="fixtures/src"
FIXTURES_OUT="fixtures/epub"

build_epub() {
    local src_dir="$1"
    local out_file="$2"
    
    mkdir -p "$(dirname "$out_file")"
    rm -f "$out_file"
    
    out_file="$(cd "$(dirname "$out_file")" && pwd)/$(basename "$out_file")"
    
    cd "$src_dir"
    if [ -f mimetype ]; then
        zip -X0 "$out_file" mimetype
        zip -Xr9D "$out_file" . -x mimetype
    else
        zip -Xr9D "$out_file" .
    fi
    cd - > /dev/null
}

for category in valid invalid; do
    if [ -d "$FIXTURES_SRC/$category" ]; then
        for fixture_dir in "$FIXTURES_SRC/$category"/*/; do
            name=$(basename "$fixture_dir")
            echo "Building: $category/$name"
            build_epub "$fixture_dir" "$FIXTURES_OUT/$category/$name.epub"
        done
    fi
done

# Build special fixtures that need non-standard zip manipulation
if [ -f scripts/build-special-fixtures.py ]; then
    python3 scripts/build-special-fixtures.py
fi

echo "Done. Built epubs in $FIXTURES_OUT/"
```

4. Build and validate against reference:
```bash
chmod +x scripts/build-fixtures.sh
./scripts/build-fixtures.sh
java -jar ~/tools/epubcheck-5.3.0/epubcheck.jar fixtures/epub/valid/minimal-epub3.epub --json reference/valid/minimal-epub3.json
```

5. **Reference epubcheck MUST report zero errors on minimal-epub3.epub.** If it reports any errors or warnings, fix the fixture until it passes cleanly. This is ground truth. Do not proceed until this is clean.

6. Create `expected/valid/minimal-epub3.json` and commit.

### Phase 2: Level 1 Invalid Fixtures — OCF Container

For each check: copy minimal-epub3, introduce ONE defect, build, run reference, examine output, create expected file, commit.

| Fixture | Defect | Expected epubcheck ID |
|---------|--------|-----------------------|
| ocf-mimetype-missing | Delete mimetype file | PKG-006 |
| ocf-mimetype-compressed | Deflate instead of stored* | PKG-007 |
| ocf-mimetype-wrong-content | "application/zip" instead of correct | PKG-007 |
| ocf-mimetype-not-first | mimetype not first zip entry* | PKG-006 |
| ocf-mimetype-extra-whitespace | Trailing newline | PKG-007 |
| ocf-mimetype-extra-field | ZIP extra field on entry* | PKG-005 |
| ocf-container-missing | Delete META-INF/container.xml | RSC-002 |
| ocf-container-malformed-xml | Broken XML | RSC-005 |
| ocf-container-no-rootfile | No rootfile element | RSC-003 |
| ocf-container-rootfile-not-found | Points to nonexistent .opf | PKG-020 |

*Starred fixtures need `scripts/build-special-fixtures.py` for non-standard zip construction:

```python
#!/usr/bin/env python3
"""Build fixtures requiring non-standard zip manipulation."""
import zipfile, os, shutil

FIXTURES_SRC = "fixtures/src"
FIXTURES_OUT = "fixtures/epub"
# Use minimal-epub3 as the base for all special fixtures
BASE = os.path.join(FIXTURES_SRC, "valid", "minimal-epub3")

def collect_files(src_dir, exclude=None):
    """Walk src_dir, yield (arcname, filepath) pairs."""
    for root, dirs, files in os.walk(src_dir):
        for f in sorted(files):
            arcname = os.path.relpath(os.path.join(root, f), src_dir)
            if exclude and arcname in exclude:
                continue
            yield arcname, os.path.join(root, f)

def build_mimetype_not_first():
    out = os.path.join(FIXTURES_OUT, "invalid", "ocf-mimetype-not-first.epub")
    os.makedirs(os.path.dirname(out), exist_ok=True)
    with zipfile.ZipFile(out, 'w') as zf:
        for arcname, filepath in collect_files(BASE, exclude={"mimetype"}):
            zf.write(filepath, arcname, compress_type=zipfile.ZIP_DEFLATED)
        zf.write(os.path.join(BASE, "mimetype"), "mimetype",
                 compress_type=zipfile.ZIP_STORED)

def build_mimetype_compressed():
    out = os.path.join(FIXTURES_OUT, "invalid", "ocf-mimetype-compressed.epub")
    os.makedirs(os.path.dirname(out), exist_ok=True)
    with zipfile.ZipFile(out, 'w') as zf:
        zf.write(os.path.join(BASE, "mimetype"), "mimetype",
                 compress_type=zipfile.ZIP_DEFLATED)
        for arcname, filepath in collect_files(BASE, exclude={"mimetype"}):
            zf.write(filepath, arcname, compress_type=zipfile.ZIP_DEFLATED)

# Add more special builders as needed...

if __name__ == "__main__":
    build_mimetype_not_first()
    build_mimetype_compressed()
    print("Special fixtures built.")
```

### Phase 3: Level 1 Invalid Fixtures — OPF & Metadata

| Fixture | Defect | Expected ID |
|---------|--------|-------------|
| opf-missing-dc-title | Remove dc:title | RSC-005 |
| opf-missing-dc-identifier | Remove dc:identifier | RSC-005 |
| opf-missing-dc-language | Remove dc:language | RSC-005 |
| opf-missing-unique-identifier | unique-identifier doesn't match | OPF-048 |
| opf-missing-dcterms-modified | Remove dcterms:modified | RSC-005 |
| opf-duplicate-manifest-id | Two items same id | OPF-074 |
| opf-manifest-href-missing | Item without href | RSC-005 |
| opf-manifest-media-type-missing | Item without media-type | RSC-005 |
| spine-bad-idref | idref="nonexistent" | OPF-049 |
| spine-empty | No itemref children | RSC-005 |

**Note on RSC-005:** Many OPF structural errors trigger RSC-005 (schema parsing error) because epubcheck validates via RelaxNG. Native implementations will likely use specific check IDs. Expected files should note this with `"note"` field explaining the divergence.

### Phase 4: Level 1 — Cross-References & Navigation & Content

| Fixture | Defect | Expected ID |
|---------|--------|-------------|
| manifest-file-not-in-zip | Manifest refs nonexistent file | RSC-001 |
| zip-entry-not-in-manifest | Extra file not in manifest | OPF-003 |
| nav-missing | No item with properties="nav" | RSC-005 |
| nav-no-toc | Nav doc missing epub:type="toc" | RSC-005 |
| content-malformed-xhtml | Unclosed tag | RSC-005 |
| content-broken-internal-link | href to nonexistent .xhtml | HTM-008 |
| content-broken-image-ref | img src to missing image | RSC-007 |

### Phase 5: checks.json Registry

After all Level 1 fixtures are built, create the full registry:

```json
{
  "version": "0.1.0",
  "epub_spec_version": "3.3",
  "reference_tool": "epubcheck-5.3.0",
  "levels": {
    "1": "Catches pandoc problems (~30 checks)",
    "2": "Daily driver replacement (~80 checks)",
    "3": "Production validator (~140 checks)",
    "4": "Full conformance (~200+ checks)"
  },
  "categories": {
    "PKG": "Container/zip structure",
    "RSC": "Resource references",
    "OPF": "Package document",
    "HTM": "HTML content documents",
    "NAV": "Navigation documents",
    "NCX": "EPUB 2 NCX",
    "CSS": "CSS validation",
    "MED": "Media types & overlays",
    "ACC": "Accessibility",
    "CHK": "Checker internals"
  },
  "checks": [
    {
      "id": "OCF-001",
      "name": "mimetype-file-present",
      "description": "The OCF zip container must include a mimetype file as the first entry",
      "spec_ref": "https://www.w3.org/TR/epub-33/#sec-zip-container-mime",
      "category": "PKG",
      "severity": "ERROR",
      "level": 1,
      "applies_to": ["epub2", "epub3"],
      "fixture_invalid": "invalid/ocf-mimetype-missing",
      "fixture_valid": "valid/minimal-epub3",
      "epubcheck_message_id": "PKG-006",
      "frequency_rank": null,
      "implemented": {}
    }
  ]
}
```

### Phase 6: Comparison Scripts

Write all scripts in `scripts/`. Key behaviors:

**generate-reference.sh**: Run epubcheck on every fixture, save JSON to reference/. Always succeeds (epubcheck returns non-zero on invalid epubs, use `|| true`).

**verify-expected.sh**: For each expected/ file, load corresponding reference/ file, compare key fields. Report mismatches. Exit non-zero if any mismatch.

**compare-implementation.sh**: Takes an implementation command as argument. Runs it on every fixture. Compares against expected/. Reports PASS/FAIL/SKIP per check. Summary line with percentage. Exit code reflects pass rate.

**parity-report.sh**: Generates markdown table of all checks with status per implementation.

### Phase 7: Discovery & Frequency Analysis

After Level 1 is solid, run discovery against real-world epubs:

**fetch-corpus.sh**: Download epub3-samples, a sample of Project Gutenberg epubs, and Standard Ebooks releases.

**discover-checks.sh**: Run epubcheck on entire corpus, collect all unique message IDs, identify which ones we don't have fixtures for yet.

**frequency-analysis.sh**: Count occurrences of each message ID across the corpus. Output ranked list. The top N unfixture'd checks become the Level 2 build list.

### Phase 8+ (future): Levels 2-4

Build fixtures driven by frequency analysis. Key Level 2 additions:
- RSC resource reference checks (005, 006, 007, 008, 012, 026)
- OPF fallback chains (040-045), MIME mismatch (013), UUID validation (085)
- HTM viewport checks (046, 047), encoding (058)
- Basic EPUB 2 with NCX

## Expected Output Format

```json
{
  "fixture": "invalid/ocf-mimetype-missing",
  "valid": false,
  "messages": [
    {
      "severity": "ERROR",
      "check_id": "OCF-001",
      "epubcheck_id": "PKG-006",
      "message_pattern": "mimetype",
      "note": ""
    }
  ],
  "fatal_count": 0,
  "error_count": 1,
  "error_count_min": null,
  "warning_count": 0
}
```

Implementations must match: `valid` status, each message's `severity`, each message's `message_pattern` (regex, case-insensitive). They do NOT need exact message text, exact cascading error counts, or identical message IDs.

Use `error_count_min` instead of exact count when epubcheck reports cascading errors from a single defect.

## Makefile

```makefile
EPUBCHECK_JAR ?= $(HOME)/tools/epubcheck-5.3.0/epubcheck.jar

.PHONY: all build reference verify compare parity discover frequency corpus clean help

all: build reference verify

build:                              ## Build epub fixtures from source
	./scripts/build-fixtures.sh

reference:                          ## Generate reference epubcheck output
	./scripts/generate-reference.sh

verify:                             ## Verify expected matches reference
	./scripts/verify-expected.sh

compare:                            ## Compare an implementation (IMPL=./path/to/tool)
	./scripts/compare-implementation.sh $(IMPL)

parity:                             ## Generate parity report (IMPL=./path/to/tool)
	./scripts/parity-report.sh $(IMPL)

discover:                           ## Discover all checks via corpus analysis
	./scripts/discover-checks.sh

frequency:                          ## Rank checks by real-world frequency
	./scripts/frequency-analysis.sh

corpus:                             ## Download real-world epub corpus
	./scripts/fetch-corpus.sh

clean:                              ## Remove generated files
	rm -rf fixtures/epub/ reference/ analysis/

help:                               ## Show this help
	@grep -E '^[a-zA-Z_-]+:.*?##' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "  %-15s %s\n", $$1, $$2}'
```

## Key Principles

1. **One defect per invalid fixture.** Each tests exactly one validation rule.
2. **Expected output is curated, not auto-generated.** Reference informs, expected decides.
3. **Fixtures are source-controlled as directories.** Epub zips are build artifacts.
4. **checks.json is the contract.** Implementations read it to know what to build and test.
5. **Comparison is against expected/, not reference/.** This lets us intentionally diverge when we have reason.
6. **Frequency drives priority.** After Level 1, real-world data tells us what matters most.
7. **Every fixture validated against reference before commit.** Reference epubcheck is ground truth for generating our expected output.

## Getting Started

```bash
./bootstrap.sh                  # Install tools (Java, epubcheck, test data)
make build                      # Build epub fixtures
make reference                  # Run reference epubcheck on all fixtures
# Examine reference/ output, create expected/ files
make verify                     # Verify expected matches reference
# Later:
make corpus                     # Download real-world epubs
make discover                   # Find all check IDs in the wild
make frequency                  # Rank checks by real-world frequency
```
